#!/bin/bash

# We will need the BOINC UserID and BOINC Authenticator as the first two parameters
AUTH_USER="35331"
AUTH_PASSWORD="4c2ce9458a4750eafd589c9b4269fc2b"
LOG_LEVEL=0

# Define URLs using base URL as reference
DB_URL="https://t4t-data-bridge.cern.ch"
DB_INPUT_QUEUE="${DB_URL}/boinc-client/get-job.cgi"
DB_OUTPUT_QUEUE="${DB_URL}/boinc-client/put-jobout.cgi"
DB_INPUT_URL="${DB_URL}/myfed/t4t-boinc/input"
DB_OUTPUT_URL="${DB_URL}/myfed/t4t-boinc/output"

# Log helper
function log {
    local LEVEL=$1
    local LEVEL_STR="DEBUG"
    shift

    # Do not log levels lower than
    # the ones specified
    [ $LEVEL -lt $LOG_LEVEL ] && return

    # Translate level to string
    if [ $LEVEL -eq 1 ]; then
        LEVEL_STR="INFO"
    elif [ $LEVEL -eq 2 ]; then
        LEVEL_STR="WARN"
    elif [ $LEVEL -eq 3 ]; then
        LEVEL_STR="ERROR"
    fi

    # Process multiline buffers
    while read L; do
        echo "[$(date '+%d/%m/%Y %H:%M:%S')] ${LEVEL_STR}: $L" 1>&2
    done <<< "$*"
}

# DAVIX I/O Helper (file-based)
function davix_io {
    local VERB=$1
    local URL=$2
    local FILE=$3
    local RET=256
    local ERROR_MSG=""
    local RETRIES=3
    shift; shift; shift

    # Extra args
    local CMDLINE="-k --userlogin \"${AUTH_USER}\" --userpass \"${AUTH_PASSWORD}\""
    for (( i = 1; i <= $# ; i++ )); do
        eval ARG=\$$i
        if [[ $ARG =~ $WHITESPACE ]]
        then
            CMDLINE="$CMDLINE \"$ARG\""
        else
            CMDLINE="$CMDLINE $ARG"
        fi
    done

    # Handle verb accordint to case
    case $VERB in
        GET)
            # Use davix-get to download a file
            CMDLINE="davix-get $CMDLINE \"${URL}\" ${FILE}"
            ;;
        PUT)
            # Use davix-put to upload a file
            CMDLINE="davix-put $CMDLINE ${FILE} \"${URL}\""
            ;;
        DELETE)
            # Use davix-rm to delete a file
            CMDLINE="davix-rm $CMDLINE \"${URL}\""
            ;;
        *)
            log 3 "Unhandled DAVIX Verb '${VERB}'"
            return 200
            ;;
    esac

    # Repeat command if it fails
    while true; do

        # Perform DAVOX I/O
        log 0 "Executing $CMDLINE"
        exec 3>&1
        ERROR_MSG=$(eval $CMDLINE 2>&1)
        RET=$?
        exec 3>&-
        log 0 "Exited with $RET"

        # If this was an error, retry
        if [[ $RET -ne 0 && $RETRIES -gt 0 ]]; then
            let RETRIES--
            log 3 "$ERROR_MSG"
            log 1 "In 10 sec will retry a DAVIX ${VERB} to ${URL}"
            sleep 10
        else
            break
        fi

    done

    # Log errors
    [ $RET -ne 0 ] && log 3 "$ERROR_MSG"

    # Return exit code
    return $RET
}

# CURL I/O Helper (payload-based)
function curl_io {
    local VERB=$1
    local URL=$2
    local RET=0
    local ERROR_MSG=""
    local WHITESPACE="[[:space:]]"
    shift; shift

    # Extra args
    local CMDLINE="curl -k -u \"${AUTH_USER}:${AUTH_PASSWORD}\""
    CMDLINE="${CMDLINE} -f -s -S -L --retry 3 --retry-delay 10 -X ${VERB}"
    for (( i = 1; i <= $# ; i++ )); do
        eval ARG=\$$i
        if [[ $ARG =~ $WHITESPACE ]]
        then
            CMDLINE="$CMDLINE \"$ARG\""
        else
            CMDLINE="$CMDLINE $ARG"
        fi
    done
    CMDLINE="${CMDLINE} \"${URL}\""

    # Perform HTTP GET
    log 0 "Executing $CMDLINE"
    exec 3>&1
    ERROR_MSG=$(eval $CMDLINE 2>&1 1>&3)
    RET=$?
    exec 3>&-

    # Log 3s
    [ $RET -ne 0 ] && log 3 "$ERROR_MSG"

    # Return exit code
    return $RET
}

# Create a junk file
[ ! -f blob ] && dd if=/dev/urandom of=blob bs=512 count=128
VALID_HASH=$(shasum -a1 blob | awk '{print $1}')

FAILURES=0
I=0
while [ $I -lt 100 ]; do

    # Sleep a while
    sleep 1

    # Prepare next iteration
    let I++
    UUID=$(uuidgen)
    URL="${DB_OUTPUT_URL}/test-${UUID}.tar.gz"
    log 1 "Test #$I, delay $I, ($UUID)"

    # Upload the blob
    davix_io PUT "${URL}" blob
    [ $? -ne 0 ] && log 3 "Unable to upload to ${URL}" && continue

    # Wait for a while
    log 1 "Delaying for $I sec"
    sleep $I

    # Download the blob
    davix_io GET "${URL}" inblob
    [ $? -ne 0 ] && log 3 "Unable to download from ${URL}"

    # Delete the blob
    davix_io DELETE "${URL}" inblob
    [ $? -ne 0 ] && log 3 "Unable to delete url ${URL}" && continue

    # Check hash
    CHECK_HASH=$(shasum -a1 inblob | awk '{print $1}')
    if [ "$CHECK_HASH" != "$VALID_HASH" ]; then
        log 3 "!!!! Hash mismatch between download and upload"
    else
        log 1 "++++ Hash matches, I/O successful after $I sec delay"
    fi

done

# Remove blobs
rm blob inblob
